* __python会缓存简单的整数__<br/><br/>

*  __str()和repr()以及' '运算符__<br/><br/>

*  __序列类型的浅拷贝，深拷贝__<br/><br/>
	1. 序列类型的拷贝默认为浅拷贝，几种浅拷贝的方式
		1. 完全切片操作
		2. 利用工厂函数，比如list()，dict()
		3. 使用copy模块的copy函数
	2. 序列浅拷贝时，序列中如果存在不可变对象，则会把不可变对象显式拷贝，可变对象则直接引用<br/><br/>

* __避免在迭代可变对象的时候修改它们，一个序列的迭代器只是记录你当前到达第多少元素，更新会立即反应到所修改的条目上，同时哈需要说明的是迭代器是与实际对象绑定起来的__<br/><br/>
* __生成器表达式与列表解释器，生成器内存友好,数据是被yield出来的，使用了延时计算__<br/><br/>
* __注意文件操作函数，text()和seek()函数，text（）返回当前文件指针在文件中的位置，seek（）可以移动文件指针到不同的位置.flush()函数刷新缓冲区，fileno()返回打开文件的描述符;truncate()函数将文件截取到当前文件指针或者到给定的size，以字节为单位__<br/><br/>
* __OS模块中有助于跨平台开发的属性：__<br/><br/>
		1. linesep    用于在文件中分隔行的字符串
		2. sep    用来分隔文件路径名的字符串
		3. pathsep 用于分隔文件路径的字符串
		4. curdir 当前工作的字符串名称
		5. pardir 当前工作目录的父目录字符串名称
* __《python 核心编程》中9.7节文件系统能够查阅OS模块所包含的属性，主要实现python对文件系统的访问__<br/><br/>

* __注意try……except……else……finally之间的逻辑关系__<br/><br/>
* __with语句：只有内建了“上下文管理”的对象可以和with一起工作，with 语句作为 try/finally 编码范式的一种替代，用于对资源访问进行控制的场合。__<br/><br/>
		1. with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。
		2. 上下文管理协议（Context Management Protocol）：包含方法 __enter__() 和 __exit__()，支持该协议的对象要实现这两个方法。
		3. 上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了__enter__()和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。
		4. 运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 __enter__() 和__exit__() 方法实现，__enter__() 方法在语句体执行之前进入运行时上下文，__exit__() 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。
		5. 上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。
		6. 语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管理器的 __enter__() 方法，执行完语句体之后会执行 __exit__() 方法。

* 		with context [as var(x)]:
    		with-body

			这里 context 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 var(x) ，如果指定了 as 子句的话，会将上下文管理器的 __enter__() 方法的返回值赋值给 var(x)。var(x) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。


			不使用with的代码可能是这样的
			var = centext.__enter__()
			try:
    			do_something(var)
			finally:
    			context.__exit__()

			上下文管理器协议允许将无聊的try...except...finally结构抽象到一个单独的类中，仅仅留下关注的do_something部分。
			
			try...finally常见的用法是释放资源。各种不同的情况实现相似：在__enter__阶段资源被获得，在__exit__阶段释放，如果抛出异常也被传递。正如文件操作，往往这是对象使用后的自然操作，内置支持使之很方便。